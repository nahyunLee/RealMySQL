# 4.2 InnoDB 스토리지 엔진 아키텍처 
- 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다 -> 레코드 기반의 잠금 
 ![image](https://user-images.githubusercontent.com/52403454/230769130-02709ac2-2caa-4993-a5d7-683a0ec1800c.png)

<br>

### 1. 프라이머리 키에 의한 클러스터링 
- InnoDB는 PK 기준으로 클러스터링 되어 저장 -> PK 값 순서대로 디스크에 저장.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 PK값을 논리적인 주소로 사용한다.  -> PK를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다. 
- ❓세컨더리 인덱스?
- 쿼리 실행 계획에서 PK는 기본적으로 다른 보조 인덱스보다 비중이 높게 설정 (다른 보조 인덱스보다 PK가 선택될 확률이 높음)
- MyISAM에서는 클러스터링 키를 지원하지 않으므로 PK와 세컨더리 인덱스는 구조적으로 아무런 차이가 없음 

<br><br>

### 2. 외래 키 지원
- FK는 InnoDB에서만 지원 
- FK는 서버 운영의 불편함 때문에 운영환경 DB에서는 잘 안쓰인다. 하지만 개발 DB에서는 가이드 역할 수행 가능 
- 불편한 이유
  - 부모/자식 테이블 모두 해당 칼럼에 인덱스 생성 필요 
  - 변경시에는 부모.자식 테이블에 데이터가 있는지 체크작업 필수라서, 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많음
  - 수동으로데이터를 적재하거나 스키마 변경등의 관리 작업이 실패할 수 있음 
  - foreign_key_checks 시스템 변수를 OFF하면 PK 관계 체크 작업 일시적으로 멈출 수 있다. 

<br><br>
### 3. MVCC ( Multi-Version Concurrency Control )
- 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법
- 레코드 레벌의 트랜잭션을 지원하는 DBMS가 제공하는 기능.
- 목적 : 잠금을 사용하지 않는 일관된 읽기를 제공
- InnoDB는 Undo log를 사용하여 MVCC기능 제공 
- Multi-Version : 하나의 레코드에 여러 개의 버전이 동시에 관리 
- 격리 수준에 따른 데이터 조회 (update 이후 commit,rollback 이전에 select한 상황)
  -  READ_UNCOMMITED : InnoDB버퍼풀의 데이터 읽어옴
  -  READ_COMMITED, REPEATSABLE_READ, SERIALIZABLE : 언두 영역의 데이터 반환 
  -  이것이 MVCC!!!! -> 하나의 레코드에 2개의 버전이 유지되고 필요에 따라 보여지는 데이터가 달라지는 구조 
- UPDATE : 버퍼풀은 즉시 새로운 데이터로 변경되고 기존 데이터는 언두 영역으로 복사됨 
  - commit : 지금의 상태를 영구적인 데이터로 만듬. 언두 영역을 필요로 하는 트랜잭션이 없을 때 백업데이터 삭제 
  - rollback : 언두 영역에 백업된 데이터를 InnoDB버퍼풀로 다시 복구. 언두 영역 삭제   

<br><br>
### 4. 잠금없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB는 MVCC를 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.  -> 다른 트랜잭션이 잠금을 기다리지 않고 읽기 작업 가능 
- READ_UNCOMMITED, READ_COMMITED, REPEATSABLE_READ : 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 실행 
- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션은 다른 사용자의 select 작업을 방해하지 않는다. (언두 로그를 읽기 때문) 
- 오랜 시간동안 활성상태인 트랜잭션에 의해 MySQL 서버가 느려지거나 문제가 발생할 때가 있음 
  - 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문에 생기는 문제
  - 트랜잭션이 시작됐다면, 가능한 빨리 롤백이나 커밋을 통해 트랜잭션 완료하자 


<br><br>
### 5. 자동 데드락 감지 
- InnoDB는 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List)형태로 관리한다. 
 - 주기적으로 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그 중 하나를 종료 
 - 어떤 트랜잭션을 먼저 강제 종료할 것인가? -> 언두 로그 레코드가 적은 트랜잭션 (롤백을 해도 언두 처리할 대상이 적다는 뜻. 강제 롤백에 의한 MySQL서버 부하 덜 유발)
- 특별한 이유가 없다면 innodb_table_locks 시스템 변수 활성화 
 - 레코드/테이블 레벨의 잠금 감지 가능 -> InnoDB는 상위 레이어인 MySQL엔진에서 관리되는 테이블 잠금을 볼 수 없어서 데드랑 감지가 불확실한 부분 감지 
- 동시 처리 스레드가 매우 많을 경우 데드락 감지 스레드는 더 많은 CPU자원을 소모할 수 있다. 
 - innodb_deadlock_detect시스템 변수를 off하면 데드락 감지 스레드는 더는 작동하지 않는다. 
 - off로 사용할거면 default인 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장  


<br><br>
### 6. 자동화된 장애 복구
- InnoDB는 여러 매터니즘을 이용해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된(Partial write)데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다. 
 - 이 떄 자동으로 복구될 수 없는 손상이 있다면 자동으로 복구를 멈추고 MySQL서버는 종료돼 버린다
 - 위의 경우에는 **innodb_force_recovery **시스템 변수를 설정해서 시작해야함.  -> 해당 값이 클수록 데이터 손실 가능성이 커지고, 복구 가능성은 적어진다. 
 - MySQL서버가 기동되고 InnoDB테이블이 인식된다면 **mysqldump**를 이용해 데이터를 가능한만큼 백업하고 그 데이터로 MySQL서버의 DB와 테이블을 다시 생성하는 것이 좋다.
 - ❓InnoDB테이블? 저번장에서 봤던 것 같은데 헷갈림;
 - innodb_force_recovery 은 1-6까지 숫자인데 각 숫자마다 복구되는 장애 상황과 해결 방법을 살펴보자 
- innodb_force_recovery 각 단계별 복구가 안된다면, 백업을 이용해 다시 구축하는 방법밖에 없다. -> 바이너리 로그로 복구 가능
 - 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 풀 백업과 바이너라 로그로 복구하는 것이, InnoDB의 복구를 이용하는 것보다 데이터 손실이 적다. 
 - 백업은 있지만 바이너리 로그가 없다면 마지막 백업 시점까지만 복구 가능 


<br><br>
### 7.InnoDB 버퍼풀
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 역할. 
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할 -> 쓰기 작업은 여기 저기의 레코드를 변경하기 떄문에 랜덤한 디스크 작업 발생 -> 이런 데이터를 모아서 한번에 처리하면 디스크 작업의 횟수를 줄일 수 있다. 


<br>

1.  버퍼풀의 크기 설정
- 운영체제와 각 클라이언트 스레드가 상용할 메모리를 충분히 고려해서 설정하자
- 레코드 버퍼 : 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 떄 버퍼로 사용하는 공간
 - 커넥션이 많고 사용하는 테이블이 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수도 있다.
 - mySQL 5.7버전부터 래코드 버퍼 공간만 별도로 동적으로 크기 조절 가능
 - 가능하면 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 방법이 최적
- innodb_buffer_pool_size시스템 변수로 크기 설정 가능 
 - 크리티컬한 변경이므로 한가한 시간에 진행
 - 늘리는 것은 OK, 줄이는 것은 위험 
- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔는데, 이런 경합을 줄이기 위해 버퍼 풀을 여러개로 쪼개어 관리할 수 있게 개선
 - innodb_buffer_poll_instances 시스템 변수를 사용해서 버퍼풀을 여러개로 분리해서 관리 가능 
 
<br>

2. 버퍼풀의 구조 
- InnoDB스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
- 버퍼풀 페이지 조각을 관리하기 위해 세가지 자료구조 사용
 1. LRU 리스트 : LRU(OLD서브리스트 영역) + MRU (New 서브리스트 영역) 결합 형태 
   - 목적 : 디스크로부터 한번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화 
   - 처음에 한번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 InnoDB버퍼 풀의 MRU영역에서 계속 살아남게 되고, 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU의 끝으로 밀려나 결국은 InnoDB버퍼풀에서 제거 
 2. 플러시 리스트 : 동기화되지 않은 데이터를 가진 데이터 페이지(더티페이지)의 변경 시점 기준의 페이지 목록 관리
   - 한번 변경이 가해진 데이터 페이지는 플러시 시르트에서 관리되고, 특정 시점이 되면 디스크로 기록되어야 한다. 
   - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다. 
   - InnoDB는 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지 상태를 동기화한다.
 3. 프리 리스트 : 버퍼풀에서 실제로 사용자 데이터로 채워지지 않은 페이지들의 목록 -> 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 


<br>

3. 버퍼풀의 리두 로그
- InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계 
- 버퍼풀이 크면 클수록 쿼리 성능이 빨라진다. -> 그렇다고 해서 무작정 메모리 공간만 늘리면 캐싱 능력만 좋아짐 (쓰기 버퍼링은 안좋아진다는 뜻)
- 버퍼풀의 성능향상을 위한 용도 : 데이터 캐시 + 쓰기 버퍼링  
  - 위의 버퍼풀 역할 두가지 다시 정리한듯 

![image](https://user-images.githubusercontent.com/52403454/230903655-778b6673-7ccb-4e5f-8266-c6b49ed9c8fb.png)
- 버퍼풀의 페이지 = 클린 페이지 + 더티 페이지
   - 클린 페이지 : 디스크에서 읽은 상태로 전혀 변경되지 않은 ㄷ페이지
   - 더티 페이지 : 디스크에서 읽은 후 write작업 된 페이지 - 디스크와 메모리(버퍼풀)의 데이터 상태가 다르기 때문에 언젠가는 디스크 기록 필요 
     - 무한정 버퍼풀에 머물 수 있는 것 아님
- 활성 리두 로그
  - 리두 로그는 고정 크기라서, 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용이 불가능한 공간을 구분해서 관리. 
  - 재사용 불가능한 공간이 활성 리두 로그. 그림에서 화살표를 가진 엔트리들 
- LSN : Log Sequence Number
  - 리두 로그 파일 공간은 계속 순환되어 재사용되지만, 기록될 때 마다 로그 포지션은 증가된 값을 가짐 -> 이게 LSN 
  - InnoDB는 주기적으로 체크포인트 이벤트를 발생시켜서 리두 로그와 버퍼 풀의 데티 페이지를 디스크로 동기화 -> 발생한 체크포인트 중 가장 최근 포인트 지점의 LSN이 활성 리두 로그의 공간의 시작점.
  - checkpoint age : 가장 최근 체크포인트의 LSN과 마지막 리두 로그의 LSN의 차이. 활성 리두 로그 공간의 크기 
- InnoDB 버퍼풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고, 체크포인트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화되어야 한다. 
- 버퍼풀보다 리두 로그 파일의 전체 크기가 클 경우 -> 급작스러운 디스크 쓰기가 발생할 확률이 높다. 버퍼풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼풀이 필요한 상황이 오면 InnoDB 스토리지 엔진은 매우 많은 더티 페이지를 한번에 기록해야 하는 상황이 온다.
  -❓리두 로그 크기가 크면, 당장 사용가능한 공간들이 많음. 재사용을 하지 않아도 그냥 빈공간 할당 가능. 그럼 재사용을 해야하는 순간이 매우 뒤에 올 텐데.. 최근 체크포인트 LSN와 마지막 리두 로그LSN차이가 너무 커서 한번에 업데이트 칠 상황이 온다.
  
<br>

4. 버퍼 풀 플러시 (Buffer Pool Flush)
- MySQL 5.6 버전 까지는 더티페이지 플러시 기능이 그다지 부드러게 처리 되지 않았음
- MySQL 5.7 -> MySQL 8.0업그레이드 되면서 데티 페이지를 디스크에 동기화하는 부분에서 예전과 같은 디스크 쓰기 폭증 현상이 일어나지 않았음.
- 관련한 시스템 변수들 큰 이슈 아니면 조정할 필요 없음. 
- InnoDB는 버퍼풀에서 아직 디스크로 저장되지 않은 더티 페이지들을 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행한다. 
  - 플러시 리스트 플러시
  - LRU 리스트 플러시 
  1. **플러시 리스트 플러시**
    - InnoDB는 리두 공간의 재활용을 위해 주기적으로 리두 로그 엔트리가 사용하는 공간을 비워야 한다. 지워지려면 반드시 디스크로 동기화해야한다. 
    - 이를 위해 주기적으로 플러시 리스트 플러시 함수를 호출해서, 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크 동기화 -> 얼마나 많은 더티 페이지를 한번에 동기화하느냐에 따라 쿼리 성능 달라짐 
    - 클리너 스레드 : 더티 페이지를 디스크로 동기화 하는 스레드 
    - InnoDB는 전체 버퍼풀이 가능 페이지의 90%를 더티 페이지를 가질 수도 있는데, 이 또한 시스템 변수로 설정 가능 
      - 더티페이지를 많이 가지고 있을 수록 디스크 쓰기 작업을 버퍼링함으로써 여러번의 디스크 쓰기를 한번으로 줄이는 효과를 극대화할 수 있다. 
    - BUT, 더티 페이지가 많아질수록 디스크 쓰기 폭발(DISK IO BRUST)현상이 발생할 가능성이 높아진다. 
      - innodb_max_dirty_pages_lwm 시스템 변수를 통해서 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게한다. 
    - Adaptive flush : 시스템 변수로 on/off -> InnoDB가 여러 설정값에 의존하지 않고 새로운 알고리즘을 사용
      - 어느 정도의 속도로 더티 페이지가 생성되는지 분석, 리두로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼풀에 유지될 수 있도록 디스크 쓰기 실행 
  2. **LRU 리스트 플러시  **
    - LRU리스트에서 사용 빈도가 가장 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이를 위해서 LRU리스트 플러시 함수가 사용된다. 
    - 페이지들을 시스템 변수 설정값만큼 스캔하기 시작해서 더티페이지는 디스크에 동기화하게 하며, 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다. 

<br>

5. 버퍼 풀 상태 백업 및 복구

 


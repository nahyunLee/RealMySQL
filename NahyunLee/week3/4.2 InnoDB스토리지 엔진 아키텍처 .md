# 4.2 InnoDB 스토리지 엔진 아키텍처 
- 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다 -> 레코드 기반의 잠금 
 ![image](https://user-images.githubusercontent.com/52403454/230769130-02709ac2-2caa-4993-a5d7-683a0ec1800c.png)

<br>

### 1. 프라이머리 키에 의한 클러스터링 
- InnoDB는 PK 기준으로 클러스터링 되어 저장 -> PK 값 순서대로 디스크에 저장.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 PK값을 논리적인 주소로 사용한다.  -> PK를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다. 
- ❓세컨더리 인덱스?
- 쿼리 실행 계획에서 PK는 기본적으로 다른 보조 인덱스보다 비중이 높게 설정 (다른 보조 인덱스보다 PK가 선택될 확률이 높음)
- MyISAM에서는 클러스터링 키를 지원하지 않으므로 PK와 세컨더리 인덱스는 구조적으로 아무런 차이가 없음 

<br><br>

### 2. 외래 키 지원
- FK는 InnoDB에서만 지원 
- FK는 서버 운영의 불편함 때문에 운영환경 DB에서는 잘 안쓰인다. 하지만 개발 DB에서는 가이드 역할 수행 가능 
- 불편한 이유
  - 부모/자식 테이블 모두 해당 칼럼에 인덱스 생성 필요 
  - 변경시에는 부모.자식 테이블에 데이터가 있는지 체크작업 필수라서, 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많음
  - 수동으로데이터를 적재하거나 스키마 변경등의 관리 작업이 실패할 수 있음 
  - foreign_key_checks 시스템 변수를 OFF하면 PK 관계 체크 작업 일시적으로 멈출 수 있다. 

<br><br>
### 3. MVCC ( Multi-Version Concurrency Control )
- 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법
- 레코드 레벌의 트랜잭션을 지원하는 DBMS가 제공하는 기능.
- 목적 : 잠금을 사용하지 않는 일관된 읽기를 제공
- InnoDB는 Undo log를 사용하여 MVCC기능 제공 
- Multi-Version : 하나의 레코드에 여러 개의 버전이 동시에 관리 
- 격리 수준에 따른 데이터 조회 (update 이후 commit,rollback 이전에 select한 상황)
  -  READ_UNCOMMITED : InnoDB버퍼풀의 데이터 읽어옴
  -  READ_COMMITED, REPEATSABLE_READ, SERIALIZABLE : 언두 영역의 데이터 반환 
  -  이것이 MVCC!!!! -> 하나의 레코드에 2개의 버전이 유지되고 필요에 따라 보여지는 데이터가 달라지는 구조 
- UPDATE : 버퍼풀은 즉시 새로운 데이터로 변경되고 기존 데이터는 언두 영역으로 복사됨 
  - commit : 지금의 상태를 영구적인 데이터로 만듬. 언두 영역을 필요로 하는 트랜잭션이 없을 때 백업데이터 삭제 
  - rollback : 언두 영역에 백업된 데이터를 InnoDB버퍼풀로 다시 복구. 언두 영역 삭제   

<br><br>
### 4. 잠금없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB는 MVCC를 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.  -> 다른 트랜잭션이 잠금을 기다리지 않고 읽기 작업 가능 
- READ_UNCOMMITED, READ_COMMITED, REPEATSABLE_READ : 다른 트랜잭션의 변경 작업과 관계 없이 항상 잠금을 대기하지 않고 바로 실행 
- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션은 다른 사용자의 select 작업을 방해하지 않는다. (언두 로그를 읽기 때문) 
- 오랜 시간동안 활성상태인 트랜잭션에 의해 MySQL 서버가 느려지거나 문제가 발생할 때가 있음 
  - 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문에 생기는 문제
  - 트랜잭션이 시작됐다면, 가능한 빨리 롤백이나 커밋을 통해 트랜잭션 완료하자 
